---
title: "Interact with DataONE data repositories with the dataone package"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The `dataone` package enables users to construct programmatic queries to DataONE data repositories. This should be very helpful for people interested in making their analyses reproducible! Here I show my workflow for locating, analyzing, and plotting Oneida Lake benthic invertebrate data all without leaving my RStudio session. 

## Setup

Let's assume that I know that my target data is on [KNB](https://knb.ecoinformatics.org/) so I start by setting up `dataone` for a node specific KNB search:

```{r }
library(dataone)

cn <- CNode("PROD")
mn <- getMNode(cn, "urn:node:KNB")
```

## Find data id

Let's also assume that, at least initially, I do not know the id of my target dataset. I only know that the dataset title should include the _benthic_ and _Oneida_ keywords. I choose to use the Solr method to query the database on the _Oneida_ keyword and filter the results to entries containing the _benthic_ keyword. I limit the result fields to _id_, _title_, and _dateModified_. For more explanation of the Solr query method see this [dataone vignette](https://github.com/DataONEorg/rdataone/blob/master/vignettes/searching-dataone.Rmd). 

```{r, message=FALSE, eval=FALSE}
(qy <- dataone::query(cn, list(
                              rows = "300", 
                              q    = "title:*Oneida*",
                              fq   = "(title:*benthic*)",
                              fl   = "id,title,dateModified"), 
                     as = "data.frame"))
```

```{r, message=FALSE, echo=FALSE}
head(qy <- dataone::query(cn, list(
                              rows = "300", 
                              q    = "title:*Oneida*",
                              fq   = "(title:*benthic*)",
                              fl   = "id,title,dateModified"), 
                     as = "data.frame"), 10)
```

As far as I know, the results returned by a KNB website query include only the entries **not** prefixed by a doi designation. Let's filter our results to exclude the doi entries and sort on the _dateModified_ field to find the most recent result version:
:

```{r, message=FALSE}
library(dplyr)
(qy <- slice(qy, grep("^doi", id, invert = TRUE)))
(qy <- arrange(qy, desc(id), desc(dateModified)))
```

## Get data package

Next, I download the data package with the `getPackage` command. This command returns the location of a zip file in the machine's temporary file system which can be fed to the `unzip` function. 

```{r eval=TRUE, message=FALSE}
resource_path <- paste0("resourceMap_", qy[1,"id"])
dt <- getPackage(mn, id = resource_path)
unzip(dt)
```

```{r eval=FALSE}
# the unzipped folder has underscores as separators rather than periods
package_path <- file.path(gsub("\\.", "_", resource_path), "data")
```

```{r eval=TRUE, echo=FALSE}
package_path <- file.path("..", gsub("\\.", "_", resource_path), "data")
```

```{r }
(flist <- list.files(package_path))
fpath <- file.path(package_path, flist[1])
dt <- read.csv(fpath, stringsAsFactors = FALSE)
head(dt)
```

## Plot data

Now that I have the dataset located, downloaded, and read into a `data.frame` object I go ahead and plot the result while facetting on organism class.

```{r plot data}
library(dplyr)
library(ggplot2)

dt <- group_by(dt, Year)
dt <- summarise_each(dt, funs(mean), 5:17)
dt <- reshape2::melt(dt, "Year")

gg <- ggplot(data = dt) + 
        geom_line(aes(x = Year, y = value)) + 
        facet_wrap(~variable)
gg
```
